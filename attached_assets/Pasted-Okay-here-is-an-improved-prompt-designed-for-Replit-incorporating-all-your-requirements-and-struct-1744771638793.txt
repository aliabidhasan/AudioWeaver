Okay, here is an improved prompt designed for Replit, incorporating all your requirements and structuring it for clarity. This prompt aims to give Replit's AI a detailed blueprint to work from.

Replit Prompt: Create the Audio Weaver Application

I. Project Goal:

Develop a web application called "Audio Weaver" that allows users to upload multiple PDF documents, receive an AI-generated podcast-style summary of the content (enhanced by user-provided context), listen to this summary as audio, and reflect on the process.

II. Core Features & Workflow:

The application should follow these steps:

Setup & API Key Input:

Provide a secure method (e.g., using Replit Secrets/Environment Variables) for the user to input and store their API keys for Google Gemini and ElevenLabs. These keys should not be exposed in the frontend code.
Ensure clear instructions for obtaining these keys.
PDF Document Upload:

Implement a user interface element allowing users to select and upload multiple PDF files simultaneously.
Display the names of the uploaded files.
Show clear progress or confirmation upon successful upload.
Context Gathering (Post-Upload Modal):

Immediately after the PDF(s) are successfully uploaded, display a modal window prompting the user for additional context.
Clearly state: "Answering these questions is optional, but will help create a more immersive and relevant audio summary."
Ask the following questions in the modal (provide text input fields for each):
a. What question are you exploring? Is there something about it you’re still puzzling over — or something you want others to think more deeply about?
b. What would you want others to know about it?
c. What caught your eye (or ear) in the documents?
d. What conversation are you hoping to start with this summary?
Include a "Submit Context" or "Skip" button.
Document Analysis & Summarization (Gemini API):

Input:
The combined text content extracted from all uploaded PDF documents.
The user's answers gathered from the context modal (if provided).
Process:
Use the Google Gemini API with the model: gemini-2.0-flash-lite.
Employ the specific System Prompt provided below (Section IV) to guide the summary generation.
Pass the user's answers from the modal as additional context for the LLM to consider when generating the summary, framing it as guidance for the desired focus or angle.
Output: A concise, engaging, podcast-style text summary (max 1000 words).
Implement subtle loading animation during this stage.
Text-to-Speech Conversion (ElevenLabs API):

Input: The complete text summary generated by Gemini.
Process:
Use the ElevenLabs API with the model: eleven_flash_v2_5.
Use the specific Voice ID: 9BWtsMINqrJLrRacOk9x.
Output: An audio file (e.g., MP3) of the summary.
Implement subtle loading animation during this stage.
Audio Playback:

Embed an HTML5 audio player on the webpage.
Load the generated audio file into the player.
Provide standard playback controls (play, pause, volume, progress bar).
Reflection (Post-Playback):

After the audio is generated and potentially played, present a new section or modal titled "Reflection".
Ask the user the following questions (provide text areas for input):
a. One thing you’re proud of about the insights generated...
b. One insight that surprised you...
c. One question you still want to explore...
d. Reflect: What’s your role in this story/topic now?
(Optional Enhancement: Consider saving these reflections alongside the session/summary, though this requires more complex state/database management).
III. Technical Specifications:

Backend: Python (using Flask or FastAPI recommended for simplicity) or Node.js (using Express).
Frontend: HTML, CSS, JavaScript. (Keep it simple, no complex framework needed unless specified otherwise).
PDF Processing: Use a suitable library (e.g., PyPDF2 or pdfminer.six for Python, pdf-parse for Node.js) to extract text from PDFs.
API Integration: Use official SDKs or standard HTTP request libraries (requests in Python, axios/Workspace in Node.js) to interact with Gemini and ElevenLabs APIs.
Database (Optional but Recommended for Keys/State): Use Replit DB, SQLite, or simple file storage (like JSON) initially for storing API keys (if not using Secrets) or potentially user session data/reflections if persistence is desired. Prioritize using Replit Secrets for API keys.
IV. Gemini System Prompt (Use Verbatim):

You are tasked with creating an immersive “deep dive” summary of the provided document content—think of the tone and style of a podcast episode from NotebookLM.

Instructions:
1. Begin with a brief, engaging introduction that sets the stage and sparks curiosity about the topic.
2. Analyze and synthesize the key information, main arguments, and most significant points from the text. Incorporate any user-provided context about their exploration questions, key interests, or desired conversation starters to shape the narrative's focus.
3. Weave these insights into a compelling, conversational narrative—imagine you’re guiding a podcast listener through the big ideas, discoveries, and nuances of the material, guided by the user's specific interests if provided.
4. Structure your summary logically: start with context, explore the main themes or segments (potentially influenced by user context), and wrap up with a succinct, thoughtful conclusion or takeaway.
5. Use an accessible tone, avoiding jargon where possible (or briefly explaining it when needed), always prioritizing clarity and flow.
6. Represent the source material accurately and faithfully, ensuring that listeners will come away informed and engaged.
7. *Strict Constraint:* The final summary MUST NOT exceed 1000 words. Aim for slightly less to ensure you stay within the limit.

Your goal: Craft a summary that not only informs but also captivates—making listeners feel like they’ve truly explored the heart of the document, potentially through the lens the user wants to emphasize.
V. User Interface (UI) & User Experience (UX):

Layout: Clean, simple, and intuitive. Focus on a clear step-by-step process for the user.
Color: Use a pleasant and accessible color scheme.
Iconography: Use clear and universally understood icons for actions like Upload, Play, Pause, Settings/API Keys, Submit.
Animation: Use subtle loading indicators (e.g., spinners) during background processes like document analysis and audio generation to provide feedback.
Error Handling: Implement basic error handling (e.g., API key issues, failed uploads, API errors) and display user-friendly messages.
VI. Key Considerations:

Security: Emphasize secure handling of API keys using Replit Secrets or environment variables.
Scalability: While not the primary focus, keep code reasonably organized for potential future enhancements.
Cost: Remind the user that API calls (Gemini, ElevenLabs) may incur costs based on usage.
Rate Limiting: Be mindful of potential API rate limits.